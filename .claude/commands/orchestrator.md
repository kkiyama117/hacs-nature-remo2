# Claude Code Orchestrator

Split complex tasks into sequential steps, where each step can contain multiple parallel subtasks.

## Workflow Pattern of the orchestrator process

1. **Initial Analysis**
   - Assess project structure and requirements
     - Read `CLAUDE.md` if not read yet to use as a reference.
   - Identify key components and dependencies
   - Plan sequential steps and parallel subtasks
   - Make subfolder for this orchestrator task in `.claude/debug/sessions/` and write the plan down `plan.md` in the subfolder
     - call this folder for the task `task_debug_folder`.
2. **Step Planning**
   - Break down into 2-4 sequential steps
   - Each step can contain multiple parallel subtasks
   - Define what context from previous steps is needed
   - Add `steps planning` section in `(task_debug_folder)/plan.md` and write about each subtask.
     - Add sentences below under the top title section of `plan.md`. The sentence is "(This is generated by `.claude/commands/orchestrator.md`. See them also when restart or continue doing this plan.)"
3. **Step-by-Step Execution**
   - Execute all subtasks within a step in parallel
   - Wait for all subtasks in current step to complete
   - Pass relevant results to next step
   - Request concise summaries (100-200 words) from each subtask
     - Create `(task_debug_folder)/step_by_step.md` and write this concise summaries in it
4. **Step Review and Adaptation**
   - After each step completion, review results
   - Validate if remaining steps are still appropriate
   - Adjust next steps based on discoveries
   - Add, remove, or modify subtasks as needed
     - And also update `(task_debug_folder)/plan.md` and `step_be_step.md`
5. **Progressive Aggregation**
   - Synthesize results from the completed step
   - Use synthesized results as context for next step
   - Build comprehensive understanding progressively
   - Maintain flexibility to adapt plan
     - And also update `(task_debug_folder)/plan.md` and `step_be_step.md`.
     - At last (when all task completed), move `(task_debug_folder)` into `.claude/debug/archive`

## Example Usage

When given "analyze test lint and commit":

**Step 1: Initial Analysis** (1 subtask)
- Analyze project structure to understand test/lint setup

**Step 2: Quality Checks** (parallel subtasks)
- Run tests and capture results
- Run linting and type checking
- Check git status and changes

**Step 3: Fix Issues** (parallel subtasks, using Step 2 results)
- Fix linting errors found in Step 2
- Fix type errors found in Step 2
- Prepare a commit message based on changes
  *Review: If no errors found in Step 2, skip fixes and proceed to commit*

**Step 4: Final Validation** (parallel subtasks)
- Re-run tests to ensure updates is working and lint to verify all issues resolved
  - See `.claude/commands/fix_error.md` and do as it says.
- Update documentation in `.claude` and add simple summary of change.
- Create commit with verified changes
  *Review: If Step 3 had no fixes, simplify to just creating commit*

## Best Practices

### Task Decomposition
- Break complex tasks into 2-4 logical sequential steps
- Identify opportunities for parallel execution within steps
- Maintain clear dependencies between steps

### Context Management
- Use concise summaries when passing context between steps
- Avoid context overflow by focusing on essential information
- Re-evaluate and adapt plans after each step completion

### Execution Strategy
- Start with comprehensive project/task analysis
- Execute independent subtasks in parallel for efficiency
- Continuously validate progress and adjust approach
- Minimize manual intervention through automation

## Adaptive Planning

The orchestrator supports dynamic workflow adaptation:
- **Progressive Understanding**: Each step builds on previous discoveries
- **Plan Modification**: Workflow can be adjusted based on findings
- **Error Recovery**: Automatic handling of common development issues
- **Context Optimization**: Efficient information passing between steps

## Key Benefits

- **Sequential Logic**: Steps execute in order, allowing later steps to use earlier results
- **Parallel Efficiency**: Within each step, independent tasks run simultaneously
- **Memory Optimization**: Each subtask gets minimal context, preventing overflow
- **Progressive Understanding**: Build knowledge incrementally across steps
- **Clear Dependencies**: Explicit flow from analysis → execution → validation

## Implementation Notes

- Always start with a single analysis task to understand the full scope
- Group related parallel tasks within the same step
- Pass only essential findings between steps (summaries, not full output)
- Use TodoWrite to track both steps and subtasks for visibility
- After each step, explicitly reconsider the plan:
    - Are the next steps still relevant?
    - Did we discover something that requires new tasks?
    - Can we skip or simplify upcoming steps?
    - Should we add new validation steps?

## Adaptive Planning Example

```
Initial Plan: Step 1 → Step 2 → Step 3 → Step 4

After Step 2: "No errors found in tests or linting"
Adapted Plan: Step 1 → Step 2 → Skip Step 3 → Simplified Step 4 (just commit)

After Step 2: "Found critical architectural issue"
Adapted Plan: Step 1 → Step 2 → New Step 2.5 (analyze architecture) → Modified Step 3
```

### Performance Optimization
- Group related operations within steps
- Minimize file system operations across parallel tasks
- Use efficient tool configurations
- Cache results when appropriate
